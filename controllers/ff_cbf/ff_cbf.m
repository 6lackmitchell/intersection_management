function [data] = ff_cbf(t,x,settings)
%pcca - Controller based on Predictive Collision Avoidance Algorithm (pcca)
%The foundation of this controller is a distributed CBF-QP control scheme
%in which an ego agent solves for the inputs for the other agents in
%addition to its own input and then implements its own solutionl.
%
% Syntax:  [data] = pcca(t,x,settings)
%
% Inputs:
%    t:        current time in sec -- float
%    x:        current state vector -- ROW vector
%    settings: struct containing the following variables
%              uLast:  control solution from previous timestep
%              wHat:   actual control minus predicted control
%              t0:     initial time for segment of FxTS nominal controller
%              Tfxt:   time horizon for nominal controller
%              tSlots: intersection enter/exit times generated by IM
%              r:      x and y position for current path
%              rdot:   xdot and ydot for current path
%              rddot:  x2dot and y2dot for current path
%
% Outputs:
%    data: struct object containing relevant data recording values
%          u:      array of control inputs for agents
%          uLast:  same as u, used to feed back in during future timestep
%          cbf:    array of current CBF values
%          tSlots: intersection enter/exit times generated by IM
%          wHat:   actual control minus predicted control
%          uNom:   nominal control solution
%
% Example: 
%    [data] = pcca(t,x,settings);
%
% Other m-files required: control_params.m
% Subfunctions: none
% MAT-files required: none
%
% Author: Mitchell Black
% Email: mblackjr@umich.edu
% Website: http://www.blackmitchell.com
% Jul 2021; Last revision: 13-Sep-2021
%------------- BEGIN CODE --------------
% Import control parameters
run('control_params.m')

% Deconstruct Settings
uLast    = settings.uLast;
wHat     = settings.wHat;
t0       = settings.t0;
Tfxt     = settings.Tfxt;
% cost     = @min_diff_nominal;
cost     = @safe_pcca;
tSlots   = settings.tSlots;
maxiter  = 200;
qpTol    = 1e-8;
options  = optimoptions('quadprog','Display','off');
% options  = optimoptions('quadprog','Display','final');

% Organize parameters
Na  = size(x,1);
Nua = Nu * Na;
Nsa = Ns * Na;
idx = [1:1:Na];

u      = zeros(Na,Nu);
uNom   = zeros(Na,Nu);
d      = zeros(Na,Ns);
mincbf = zeros(Na,1);
sols   = zeros(Na,Nu*Na);

tSlots = assign_tslots(t,x,tSlots);

for aa = 1:Na
    % PCCA Control Variables
    sat_vec  = [umax(1); umax(2)];
    ctrl_idx = (-1:0)+aa*Nu;
    u00      = zeros(Nu*Na,1);
        
    % Configure path settings for nominal controller
    r           = settings.r;
    rdot        = settings.rdot;
    r2dot       = settings.rddot;

    % Augment state with beta angle
    beta = atan(Lr/(Lr+Lf)*uLast(aa,1));
    state = x(aa,:);
    u0    = zeros(Nu,1);
    
    % Generate nominal control input from trajectory tracking controller
    u0  = ailon2020_kb_tracking_fxts(t,state,r(aa,:),rdot(aa,:),r2dot(aa,:),t0(aa),aa);
    u0  = min(sat_vec,max(-sat_vec,u0));
    u00(ctrl_idx) = u0;

    % Control Constraints
    Ac  = kron(eye(Nu*Na),[1; -1]); %Ac  = Ac(3:4,:);
    bc  = repmat([umax(1); umax(1); umax(2); umax(2)],Na,1);%[umax(2); umax(2)];
    LB  = -repmat([umax(1); umax(2)],Na,1);
    UB  =  repmat([umax(1); umax(2)],Na,1);

    % Class K Functions -- alpha(B) = a*B
    Ak  = [];
    bk  = [];
    
    % Safety-Compensating PCCA Control
    pcca_settings = struct('Na',     Na,     ...
                           'AAA',    aa,     ...
                           'tSlots', tSlots, ...
                           'wHat',   wHat,   ...
                           'uLast',  uLast(:,1));
%     [As,bs,hs] = get_ffcbf_safety_constraints_dynamic(t,x,pcca_settings);
    [As,bs,hs] = get_ffcbf_safety_constraints_dynamic_solo(t,x,pcca_settings);
%     [As,bs,hs] = get_ffcbf_safety_constraints_dynamic_pcca(t,x,pcca_settings);
    
    % Load Optimization Cost Fcn
%     [Q,p] = cost(u00,repmat(q,Na,1),Nu*Na,0,Ns);
    [Q,p] = cost(u00,repmat(q,Na,1),Nu*Na,hs,ctrl_idx);
%     uLast(aa,:) = sol1(1:Nu);    

    % Constraint Matrix
%     A = [Ac; Ak; As];
%     b = [bc; bk; bs] - strict_tol;

    A = As;
    b = bs;
    
    % Count
    count     = 0;
    max_count = 5;

    % Solve Optimization problem
    % 1/2*x^T*Q*x + p*x subject to Ax <= b
    [sol,fval,exitflag] = solve_quadratic_program(Q,p,A,b,[],[],LB,UB);        

%     sol_guess = [];
%     exitflag  = 0;
%     while exitflag ~= 2 && count < max_count
%         [sol,fval,exitflag,output] = solve_quadratic_program(Q,p,A,b,[],[],LB,UB);
% %         [sol,fval,exitflag,output] = quadprog(Q,p,A,b,[],[],[],[],sol_guess,options);
% %         [sol,fval,exitflag,output] = quadprog(Q,p,A,b,[],[],LB,UB,sol_guess,options);
%         
%         if exitflag == 0
%             % Number of iterations exceeded
%             count = count + 1;
%             options  = optimoptions('quadprog','Display','off','MaxIter',maxiter*(count+1),'TolFun',qpTol*10^((2*count)));
%             [sol,fval,exitflag,output] = quadprog(Q,p,A,b,[],[],[],[],[],options);
%             continue
%             
%         elseif exitflag == -2
%             % Is it actually infeasible? Try solving feasibility problem
%             count = count + 1;
%             ff = zeros(size(Q,1),1);
%             lin_options  = optimoptions('linprog','Display','off');
%             [sol_feas,fval,exitflag,output] = linprog(ff,A,b,[],[],[],[],lin_options);
%             if exitflag == 1
%                 % Okay, so it is actually feasible...
%                 sol_guess = sol_feas;
%                 
%                 % Try changing the tolerances (w/ display on)
% %                 qp_options = optimoptions('quadprog','Display','iter','MaxIter',maxiter*(count+1),'TolFun',qpTol*10^((2*count)),'TolX',qpTol*10^((2*count)));
% %                 qp_options = optimoptions('quadprog','Display','iter','MaxIter',maxiter*(count+1),'TolCon',qpTol*10^(-(4*count)),'TolX',qpTol*10^((2*count)));
%                 qp_options = optimoptions('quadprog','MaxIter',maxiter*(count+1),'TolCon',qpTol*10^(-(4*count)),'TolX',qpTol*10^((2*count)));
%                 [sol,fval,exitflag,output] = quadprog(Q,p,A,b,[],[],[],[],[],qp_options);
%             else
%                 % Actually infeasible
%                 disp(t);
%                 disp(exitflag);
%                 disp(aa)
%                 disp('Error');
%                 return
%             end
% 
%         elseif exitflag < 0 
%             % Error
%             disp(t);
%             disp(exitflag);
%             disp(aa)
%             disp('Error');
%             return
% 
%         end
%     
%     end
    
%     if count == max_count
%         sol = u00;
%     end
    
    if exitflag ~= 2
        disp(t);
        disp(exitflag);
        disp(aa)
        disp('Error');
        return
    end
           
    u(aa,:)     = sol(ctrl_idx);
    uLast(aa,:) = u(aa,:);
    uNom(aa,:)  = u0;
    mincbf(aa)  = min([hs; 100]);
    sols(aa,:)  = sol;

end

% Determine new values for wHat: wHat_ij = u_jj - u_ij
wHat = repmat(reshape(u',1,Na*Nu),Na,1) - sols;

% Configure relevant variables for logging
u     = permute(reshape(u,[1 Na Nu]),[1 2 3]);
cbf   = mincbf;%min(mincbf);

% Organize data
data = struct('u',      u,      ...
              'uLast',  uLast,  ...
              'cbf',    cbf,    ...
              'tSlots', tSlots, ...
              'wHat',   wHat,   ...
              'uNom',   uNom);


end
%------------- END OF CODE --------------
